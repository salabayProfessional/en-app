{"ast":null,"code":"import { allWords } from \"../mockData/words\";\n\nconst generateString = () => Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n\nconst shuffle = array => {\n  return array.sort(() => Math.random() - 0.5);\n};\n\nconst equalAnswerAndWord = (test, answers, options, random, startTime) => {\n  const type = options.type === \"en-ua\" ? \"ua\" : \"en\";\n  const words = test.words.map(word => word[type].toLowerCase());\n  const sortAnswers = random.map((_, idx) => answers[random.findIndex(e => e === idx)]);\n  const audit = words.filter((word, idx) => checkAnswer(word, sortAnswers[idx]));\n  const endDate = new Date();\n  return {\n    name: (test === null || test === void 0 ? void 0 : test.name) ? test.name : \"random\",\n    type: options.type,\n    words: test.words,\n    result: audit,\n    answers: sortAnswers,\n    options,\n    endDate,\n    startTime\n  };\n};\n\nconst createTest = words => (amount = 10) => {\n  let randomID = [];\n  let result = {\n    name: generateString(),\n    words: []\n  };\n\n  for (let i = 0; i < amount; i++) {\n    randomID.push(Math.floor(Math.random() * 68));\n  }\n\n  ;\n  randomID.map(id => result.words.push(words[id]));\n  return result;\n};\n\nconst checkAnswer = (word, answer) => {\n  return answer.toLowerCase().includes(word);\n};\n\nconst makeTest = createTest(allWords);\nexport { shuffle, generateString, equalAnswerAndWord, makeTest }; // const checkAnswer = (word, answer) => {\n//   const splitWord = f(word.split(\"\"));\n//   const splitAnswer = f(answer.split(\"\"));\n//   const coincidence = splitWord.filter((l) => splitAnswer.includes(l));\n//   const necessaryTrue = coincidence.length / 100 * 80;\n//   const result = coincidence.length >= necessaryTrue? true : false;\n//   return {result,splitWord, splitAnswer, coincidence, necessaryTrue, result }\n// };","map":{"version":3,"sources":["/Users/macbookpro/Documents/GitHub/en-app/src/specialFunction/specialFunction.ts"],"names":["allWords","generateString","Math","random","toString","replace","substr","shuffle","array","sort","equalAnswerAndWord","test","answers","options","startTime","type","words","map","word","toLowerCase","sortAnswers","_","idx","findIndex","e","audit","filter","checkAnswer","endDate","Date","name","result","createTest","amount","randomID","i","push","floor","id","answer","includes","makeTest"],"mappings":"AAAA,SAASA,QAAT,QAAyB,mBAAzB;;AAEA,MAAMC,cAAc,GAAG,MAAMC,IAAI,CAACC,MAAL,GAAcC,QAAd,CAAuB,EAAvB,EAA2BC,OAA3B,CAAmC,UAAnC,EAA+C,EAA/C,EAAmDC,MAAnD,CAA0D,CAA1D,EAA6D,CAA7D,CAA7B;;AAEA,MAAMC,OAAO,GAAIC,KAAD,IAAgB;AAC9B,SAAOA,KAAK,CAACC,IAAN,CAAW,MAAMP,IAAI,CAACC,MAAL,KAAgB,GAAjC,CAAP;AACD,CAFD;;AAIA,MAAMO,kBAAkB,GAAG,CACzBC,IADyB,EAEzBC,OAFyB,EAGzBC,OAHyB,EAIzBV,MAJyB,EAKzBW,SALyB,KAMtB;AACH,QAAMC,IAAI,GAAIF,OAAO,CAACE,IAAR,KAAiB,OAAjB,GAA2B,IAA3B,GAAkC,IAAhD;AACA,QAAMC,KAAK,GAAGL,IAAI,CAACK,KAAL,CAAWC,GAAX,CAAgBC,IAAD,IAAeA,IAAI,CAACH,IAAD,CAAJ,CAAWI,WAAX,EAA9B,CAAd;AACA,QAAMC,WAAW,GAAGjB,MAAM,CAACc,GAAP,CAAW,CAACI,CAAD,EAAIC,GAAJ,KAAYV,OAAO,CAACT,MAAM,CAACoB,SAAP,CAAkBC,CAAD,IAAOA,CAAC,KAAKF,GAA9B,CAAD,CAA9B,CAApB;AAEA,QAAMG,KAAK,GAAGT,KAAK,CAACU,MAAN,CAAa,CAACR,IAAD,EAAeI,GAAf,KAA+BK,WAAW,CAACT,IAAD,EAAOE,WAAW,CAACE,GAAD,CAAlB,CAAvD,CAAd;AACA,QAAMM,OAAO,GAAG,IAAIC,IAAJ,EAAhB;AAEA,SAAO;AACLC,IAAAA,IAAI,EAAE,CAAAnB,IAAI,SAAJ,IAAAA,IAAI,WAAJ,YAAAA,IAAI,CAAEmB,IAAN,IAAYnB,IAAI,CAACmB,IAAjB,GAAwB,QADzB;AAELf,IAAAA,IAAI,EAAEF,OAAO,CAACE,IAFT;AAGLC,IAAAA,KAAK,EAAEL,IAAI,CAACK,KAHP;AAILe,IAAAA,MAAM,EAAEN,KAJH;AAKLb,IAAAA,OAAO,EAAEQ,WALJ;AAMLP,IAAAA,OANK;AAOLe,IAAAA,OAPK;AAQLd,IAAAA;AARK,GAAP;AAUD,CAxBD;;AA0BA,MAAMkB,UAAe,GAAIhB,KAAD,IAAgB,CAACiB,MAAc,GAAG,EAAlB,KAAyB;AAC/D,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIH,MAAW,GAAG;AAACD,IAAAA,IAAI,EAAE7B,cAAc,EAArB;AAAyBe,IAAAA,KAAK,EAAE;AAAhC,GAAlB;;AAEA,OAAI,IAAImB,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGF,MAAnB,EAA4BE,CAAC,EAA7B,EAAiC;AAC/BD,IAAAA,QAAQ,CAACE,IAAT,CAAclC,IAAI,CAACmC,KAAL,CAAWnC,IAAI,CAACC,MAAL,KAAgB,EAA3B,CAAd;AACD;;AAAA;AAED+B,EAAAA,QAAQ,CAACjB,GAAT,CAAcqB,EAAD,IAAaP,MAAM,CAACf,KAAP,CAAaoB,IAAb,CAAkBpB,KAAK,CAACsB,EAAD,CAAvB,CAA1B;AAEA,SAAOP,MAAP;AACD,CAXD;;AAaA,MAAMJ,WAAW,GAAG,CAACT,IAAD,EAAeqB,MAAf,KAAkC;AACpD,SAAOA,MAAM,CAACpB,WAAP,GAAqBqB,QAArB,CAA8BtB,IAA9B,CAAP;AACD,CAFD;;AAIA,MAAMuB,QAAQ,GAAGT,UAAU,CAAChC,QAAD,CAA3B;AAEA,SACEO,OADF,EAEEN,cAFF,EAGES,kBAHF,EAIE+B,QAJF,G,CAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { allWords } from \"../mockData/words\";\n\nconst generateString = () => Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n\nconst shuffle = (array: any) => {\n  return array.sort(() => Math.random() - 0.5);\n};\n\nconst equalAnswerAndWord = (\n  test: any,\n  answers: string[],\n  options: any,\n  random: number[],\n  startTime: string,\n) => {\n  const type =  options.type === \"en-ua\" ? \"ua\" : \"en\";\n  const words = test.words.map((word: any) => word[type].toLowerCase());\n  const sortAnswers = random.map((_, idx) => answers[random.findIndex((e) => e === idx) as any]);\n\n  const audit = words.filter((word: string, idx: number) => checkAnswer(word, sortAnswers[idx]));\n  const endDate = new Date();\n\n  return {\n    name: test?.name? test.name : \"random\",\n    type: options.type,\n    words: test.words,\n    result: audit,\n    answers: sortAnswers,\n    options,\n    endDate,\n    startTime,\n  };\n};\n\nconst createTest: any = (words: any) => (amount: number = 10) => {\n  let randomID = [];\n  let result: any = {name: generateString(), words: []};\n\n  for(let i = 0; i < amount ; i++) {\n    randomID.push(Math.floor(Math.random() * 68));\n  };\n\n  randomID.map((id: any) => result.words.push(words[id]));\n\n  return result\n};\n\nconst checkAnswer = (word: string, answer: string) => {\n  return answer.toLowerCase().includes(word);\n};\n\nconst makeTest = createTest(allWords);\n\nexport {\n  shuffle,\n  generateString,\n  equalAnswerAndWord,\n  makeTest,\n}\n\n// const checkAnswer = (word, answer) => {\n//   const splitWord = f(word.split(\"\"));\n//   const splitAnswer = f(answer.split(\"\"));\n//   const coincidence = splitWord.filter((l) => splitAnswer.includes(l));\n//   const necessaryTrue = coincidence.length / 100 * 80;\n//   const result = coincidence.length >= necessaryTrue? true : false;\n//   return {result,splitWord, splitAnswer, coincidence, necessaryTrue, result }\n// };\n"]},"metadata":{},"sourceType":"module"}